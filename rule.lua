--- Definition of CA rules
-- @module forma.rule
local rule = {}

local thispath = select('1', ...):match(".+%.") or ""
local pattern = require(thispath .. 'pattern')

--- Rule parsing
-- Takes a string signature i.e "X1234" and converts it into a boolean lookup-table
-- @param nbh the requested neighbourhood of the rule
-- @param rulesub the string signature in question
-- @return a boolean look-up table for the rule
local function parse_rule(nbh, rulesub)
    local ruletable = {}
    for i=2,#rulesub,1 do
        local nv = tonumber(string.sub(rulesub,i,i))
        assert(nv ~= nil, "forma.rule attempting to parse nil rulesub: " .. rulesub .." " ..string.sub(rulesub,i,i))
        assert(nv >= 0, nv <= #nbh,  "Requested rule " .. rulesub .. " cannot be accomodated into neighbourhood")
        assert(ruletable[nv] == nil, "Requested rule " .. rulesub .. " includes duplicate values")
        ruletable[nv] = true
    end
    return ruletable
end
--- Rule generation.
-- Takes a string signature, either by hand or generated by genSig.
-- @param neighbourhood specifying the neighbourhood the rule is to be applied in
-- @param rulesig string specifying the ruleset (i.e B23/S1)
-- @return a verified rule for CA
function rule.new(neighbourhood, rulesig)
    assert(type(neighbourhood) == 'table', "forma.rule.new: first argument must be a neighbourhood table")
    assert(type(rulesig) == 'string', "forma.rule: parse_rules trying to parse a " .. type(rulesig))
	local Bpos, Spos = string.find(rulesig, 'B'), string.find(rulesig, 'S')
	assert(Bpos == 1 and Spos ~= nil, "forma.rule: parse_rules cannot understand rule " .. rulesig)
    local Brule, Srule = string.sub(rulesig, 1, Spos-2), string.sub(rulesig, Spos, #rulesig)
	local newrule = {neighbourhood = neighbourhood}
    newrule.B = parse_rule(neighbourhood, Brule)
    newrule.S = parse_rule(neighbourhood, Srule)
	return newrule
end
--- Pattern neighbour count.
-- Counts how many adjacent points there are to vec
-- @param pa provided pattern for neighbour count
-- @param pt point in pattern for neighbour count
-- @param nbh neighbourhood for testing
-- @return square forma.pattern of size {x,y}
local function nCount(pa, pt, nbh)
	local n = 0
	for i=1,#nbh,1 do
		local tpt = pt + nbh[i]
		if pattern.point(pa, tpt.x, tpt.y) ~= nil then n = n + 1 end
	end
	return n
end
--- Ruleset pass/fail analysis
-- This function assesses whether or not a cell should be alive
function rule.check(ruleset, ipattern, ipoint)
    local alive_cell = true -- Start by assuming the cell will be alive
     for i=1, #ruleset, 1 do
        local irule = ruleset[i]
	    local count = nCount(ipattern, ipoint, irule.neighbourhood)
	    local alive = pattern.point(ipattern, ipoint.x, ipoint.y) ~= nil
	    if     alive == false and irule.B[count] ~= true then  -- Birth
             alive_cell = false break
	    elseif alive == true  and irule.S[count] ~= true then  -- Survival
             alive_cell = false break
	    end
     end
    return alive_cell
end
return rule
