<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>forma Reference Manual</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>forma</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/forma.cell.html">forma.cell</a></li>
  <li><a href="../modules/forma.neighbourhood.html">forma.neighbourhood</a></li>
  <li><strong>forma.pattern</strong></li>
  <li><a href="../modules/forma.point.html">forma.point</a></li>
  <li><a href="../modules/forma.rule.html">forma.rule</a></li>
</ul>
<h2>Examples</h2>
<ul class="nowrap">
  <li><a href="../examples/carpet.lua.html">carpet.lua</a></li>
  <li><a href="../examples/caves.lua.html">caves.lua</a></li>
  <li><a href="../examples/corridors.lua.html">corridors.lua</a></li>
  <li><a href="../examples/layout.lua.html">layout.lua</a></li>
  <li><a href="../examples/voronoi.lua.html">voronoi.lua</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>forma.pattern</code></h1>
<p>Pattern tables.</p>
<p></p>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#new">new ()</a></td>
	<td class="summary">Initialise a forma.pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#clone">clone (ip)</a></td>
	<td class="summary">Copy an existing forma.pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#square">square (x, y)</a></td>
	<td class="summary">Basic square pattern</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#__tostring">__tostring (self)</a></td>
	<td class="summary">Pattern tostring.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#__add">__add (a, b)</a></td>
	<td class="summary">Pattern addition</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#__sub">__sub (a, b)</a></td>
	<td class="summary">Pattern subtraction</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#__eq">__eq (a, b)</a></td>
	<td class="summary">Pattern equality</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#size">size (ip)</a></td>
	<td class="summary">Determine the number of points in a pattern</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#insert">insert (ip, x, y)</a></td>
	<td class="summary">Point insertion into a pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#point">point (ip, x, y)</a></td>
	<td class="summary">Pattern point method</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#rpoint">rpoint (ip, rng)</a></td>
	<td class="summary">Pattern random point method.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#random">random (domain, pr, rng)</a></td>
	<td class="summary">Random pattern method.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#com">com (ip)</a></td>
	<td class="summary">Pattern centre of mass point method.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#edge">edge (ip, dirs)</a></td>
	<td class="summary">Generate a pattern consisting of edge tiles to a provided pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#surface">surface (ip, dirs)</a></td>
	<td class="summary">Generate a pattern consisting of surface to a provided pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#intersection">intersection (...)</a></td>
	<td class="summary">Generate a pattern consisting of the intersection of existing patterns</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#sum">sum (...)</a></td>
	<td class="summary">Generate a pattern consisting of the sum of existing patterns</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#floodfill">floodfill (ip, ipt, dirs)</a></td>
	<td class="summary">Returns the contiguous sub-pattern of ip that surrounts point pt</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#segments">segments (ip, dirs)</a></td>
	<td class="summary">Generate a list of contiguous 'segments' or sub-patterns
 This performs a series of flood-fill operations until all
 pattern points are accounted for in the sub-patterns</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#enclosed">enclosed (ip, dirs)</a></td>
	<td class="summary">Returns a list of 'enclosed' segments of a pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#voronoi">voronoi (points, domain, measure)</a></td>
	<td class="summary">Generate voronoi segments of a given domain from a given set of points</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#limiteval">limiteval (ip)</a></td>
	<td class="summary">Re-evaluate pattern limits.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#normalise">normalise (ip)</a></td>
	<td class="summary">Normalise a pattern such that it's origin is (0,0)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#shift">shift (ip, x, y)</a></td>
	<td class="summary">Shift a pattern by (x,y)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#smear">smear (ip, ss)</a></td>
	<td class="summary">Smear a pattern out by converting all points to blocks of size ss</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#unsmear">unsmear (ip, ss)</a></td>
	<td class="summary">Inverse operation of pattern.smear.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#enlarge">enlarge (ip, f)</a></td>
	<td class="summary">Enlarges a pattern by a specific factor</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#maxrectangle">maxrectangle (ip)</a></td>
	<td class="summary">Find the maximal rectangular area within a pattern
 Algorithm from http://www.drdobbs.com/database/the-maximal-rectangle-problem/184410529</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#maxrectangle_pattern">maxrectangle_pattern (ip)</a></td>
	<td class="summary">Returns the pattern associated with the maximum rectangle of another pattern
 The returned pattern is in the same coordinate system as the parent.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#bsp">bsp (rules, ip, sps)</a></td>
	<td class="summary">Performs a binary space partition upon a given pattern, returning the
 partitioned subpatterns.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#packtile">packtile (a, b)</a></td>
	<td class="summary">Finds a position where pattern a can fit into pattern b and returns the shift required
 This operation does not allow for rotations</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#packtile_centre">packtile_centre (a, b)</a></td>
	<td class="summary">Center-weighted version of pattern.packtile, tries to fit
 pattern a into as close as possible to pattern b's centre</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "new"></a>
    <strong>new ()</strong>
    </dt>
    <dd>
    Initialise a forma.pattern.



    <h3>Returns:</h3>
    <ol>

        new pattern
    </ol>




</dd>
    <dt>
    <a name = "clone"></a>
    <strong>clone (ip)</strong>
    </dt>
    <dd>
    Copy an existing forma.pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         input pattern for cloning
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        new forma.pattern copy of ip
    </ol>




</dd>
    <dt>
    <a name = "square"></a>
    <strong>square (x, y)</strong>
    </dt>
    <dd>
    Basic square pattern


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
         size in x
        </li>
        <li><span class="parameter">y</span>
         size in y (default y = x)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        square forma.pattern of size {x,y}
    </ol>




</dd>
    <dt>
    <a name = "__tostring"></a>
    <strong>__tostring (self)</strong>
    </dt>
    <dd>
    Pattern tostring.
 Prints the stored pattern to string, using pattern.onchar
 for points and pattern.offchar for unactivated points


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">self</span>

        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        pattern as string
    </ol>




</dd>
    <dt>
    <a name = "__add"></a>
    <strong>__add (a, b)</strong>
    </dt>
    <dd>
    Pattern addition


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         first pattern to be added
        </li>
        <li><span class="parameter">b</span>
         second pattern to be added
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        new forma.pattern consisting of the superset of patterns a and b
    </ol>




</dd>
    <dt>
    <a name = "__sub"></a>
    <strong>__sub (a, b)</strong>
    </dt>
    <dd>
    Pattern subtraction


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         base pattern
        </li>
        <li><span class="parameter">b</span>
         pattern to be subtracted from a
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        new forma.pattern consisting of the subset of points in a which are not in b
    </ol>




</dd>
    <dt>
    <a name = "__eq"></a>
    <strong>__eq (a, b)</strong>
    </dt>
    <dd>
    Pattern equality


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         first pattern for equality check
        </li>
        <li><span class="parameter">b</span>
         second pattern for equality check
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true if patterns are identical, false if not
    </ol>




</dd>
    <dt>
    <a name = "size"></a>
    <strong>size (ip)</strong>
    </dt>
    <dd>
    Determine the number of points in a pattern


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for size check
        </li>
    </ul>





</dd>
    <dt>
    <a name = "insert"></a>
    <strong>insert (ip, x, y)</strong>
    </dt>
    <dd>
    Point insertion into a pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for point insertion
        </li>
        <li><span class="parameter">x</span>
         first coordinate of new point
        </li>
        <li><span class="parameter">y</span>
         second coordinate of new point
        </li>
    </ul>





</dd>
    <dt>
    <a name = "point"></a>
    <strong>point (ip, x, y)</strong>
    </dt>
    <dd>
    Pattern point method


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for point check
        </li>
        <li><span class="parameter">x</span>
         first coordinate of point to be returned
        </li>
        <li><span class="parameter">y</span>
         second coordinate of point to be returned
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the point at (x,y)
    </ol>




</dd>
    <dt>
    <a name = "rpoint"></a>
    <strong>rpoint (ip, rng)</strong>
    </dt>
    <dd>
    Pattern random point method.
 Returns a point at random from the pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for random point retrieval
        </li>
        <li><span class="parameter">rng</span>
         (optional )A random number generating table, following the signature of math.random.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a random point in the pattern
    </ol>




</dd>
    <dt>
    <a name = "random"></a>
    <strong>random (domain, pr, rng)</strong>
    </dt>
    <dd>
    Random pattern method.
 For a given domain, returns a pattern sampling uniformly from it with probability pr.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">domain</span>
         pattern for generating a random pattern on
        </li>
        <li><span class="parameter">pr</span>
         the probability of sampling a point in the domain
        </li>
        <li><span class="parameter">rng</span>
         (optional )A random number generating table, following the signature of math.random.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a pattern sampled uniformly from domain with probability pr
    </ol>




</dd>
    <dt>
    <a name = "com"></a>
    <strong>com (ip)</strong>
    </dt>
    <dd>
    Pattern centre of mass point method.
 Returns the point closes to the mass-centre of the pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for centre of mass retrieval
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the centre of mass point in the pattern
    </ol>




</dd>
    <dt>
    <a name = "edge"></a>
    <strong>edge (ip, dirs)</strong>
    </dt>
    <dd>
    Generate a pattern consisting of edge tiles to a provided pattern.
 Note that this will *not* necessarily generate a hull, it just returns the
 inactive neighbours of the provided pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for which the edges should be calculated
        </li>
        <li><span class="parameter">dirs</span>
         defines which directions to scan in to determine edges (default 8)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the forma.pattern represeting the edge of ip
    </ol>




</dd>
    <dt>
    <a name = "surface"></a>
    <strong>surface (ip, dirs)</strong>
    </dt>
    <dd>
    Generate a pattern consisting of surface to a provided pattern.
 This is simmilar to pattern.edge, but will return tiles that are /internal/
 to the provided pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for which the surface should be calculated
        </li>
        <li><span class="parameter">dirs</span>
         defines which directions to scan in to determine edges (default 8)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the forma.pattern represeting the surface of ip
    </ol>




</dd>
    <dt>
    <a name = "intersection"></a>
    <strong>intersection (...)</strong>
    </dt>
    <dd>
    Generate a pattern consisting of the intersection of existing patterns


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         patterns for intersection calculation
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the forma.pattern representing the intersection of the arguments
    </ol>




</dd>
    <dt>
    <a name = "sum"></a>
    <strong>sum (...)</strong>
    </dt>
    <dd>
    Generate a pattern consisting of the sum of existing patterns


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         patterns for summation
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the forma.pattern represeting the sum of the arguments
    </ol>




</dd>
    <dt>
    <a name = "floodfill"></a>
    <strong>floodfill (ip, ipt, dirs)</strong>
    </dt>
    <dd>
    Returns the contiguous sub-pattern of ip that surrounts point pt


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern upon which the flood fill is to be performed
        </li>
        <li><span class="parameter">ipt</span>
         specifies where the flood fill should begin
        </li>
        <li><span class="parameter">dirs</span>
         defines which directions to scan in while flood-filling (default 8)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a forma.pattern consisting of the contiguous segment about point
    </ol>




</dd>
    <dt>
    <a name = "segments"></a>
    <strong>segments (ip, dirs)</strong>
    </dt>
    <dd>
    Generate a list of contiguous 'segments' or sub-patterns
 This performs a series of flood-fill operations until all
 pattern points are accounted for in the sub-patterns


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for which the segments are to be extracted
        </li>
        <li><span class="parameter">dirs</span>
         defines which directions to scan in while flood-filling (default 8)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a table of forma.patterns consisting of contiguous sub-patterns of ip
    </ol>




</dd>
    <dt>
    <a name = "enclosed"></a>
    <strong>enclosed (ip, dirs)</strong>
    </dt>
    <dd>
    Returns a list of 'enclosed' segments of a pattern.
 Enclosed areas are the inactive areas of a pattern which are
 completely surrounded by active areas


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for which the enclosed areas should be computed
        </li>
        <li><span class="parameter">dirs</span>
         defines which directions to scan in while flood-filling (default 4)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a list of forma.patterns comprising the enclosed areas of ip
    </ol>




</dd>
    <dt>
    <a name = "voronoi"></a>
    <strong>voronoi (points, domain, measure)</strong>
    </dt>
    <dd>
    Generate voronoi segments of a given domain from a given set of points


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">points</span>
         the set of seed points for the tesselation
        </li>
        <li><span class="parameter">domain</span>
         the domain of the tesselation
        </li>
        <li><span class="parameter">measure</span>
         the measure used to judge distance between points
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a list of voronoi segments
    </ol>




</dd>
    <dt>
    <a name = "limiteval"></a>
    <strong>limiteval (ip)</strong>
    </dt>
    <dd>
    Re-evaluate pattern limits.
 The limits are usually set to the maximum extent
 (ignoring removed points), to maintain consistency with subpatterns.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for which the limits should be re-evaluated.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the shift in origin and maximum as forma.points - dmin, dmax
    </ol>




</dd>
    <dt>
    <a name = "normalise"></a>
    <strong>normalise (ip)</strong>
    </dt>
    <dd>
    Normalise a pattern such that it's origin is (0,0)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern to be normalised
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a new normalised forma.pattern
    </ol>




</dd>
    <dt>
    <a name = "shift"></a>
    <strong>shift (ip, x, y)</strong>
    </dt>
    <dd>
    Shift a pattern by (x,y)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern to be shifted
        </li>
        <li><span class="parameter">x</span>
         first coordinate of shift
        </li>
        <li><span class="parameter">y</span>
         second coordinate of shift
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a new forma.pattern consisting of ip shifted by (x,y)
    </ol>




</dd>
    <dt>
    <a name = "smear"></a>
    <strong>smear (ip, ss)</strong>
    </dt>
    <dd>
    Smear a pattern out by converting all points to blocks of size ss


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for smearing
        </li>
        <li><span class="parameter">ss</span>
         size of pattern smear
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        smeared pattern
    </ol>




</dd>
    <dt>
    <a name = "unsmear"></a>
    <strong>unsmear (ip, ss)</strong>
    </dt>
    <dd>
    Inverse operation of pattern.smear.
 Note that the process is not invertible, the best you can do is return
 a pattern, which under smearing, will give you the original pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for unsmearing
        </li>
        <li><span class="parameter">ss</span>
         size of pattern smear
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        unsmeared pattern
    </ol>




</dd>
    <dt>
    <a name = "enlarge"></a>
    <strong>enlarge (ip, f)</strong>
    </dt>
    <dd>
    Enlarges a pattern by a specific factor


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern to be enlarged
        </li>
        <li><span class="parameter">f</span>
         factor of enlargement
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        enlarged pattern
    </ol>




</dd>
    <dt>
    <a name = "maxrectangle"></a>
    <strong>maxrectangle (ip)</strong>
    </dt>
    <dd>
    Find the maximal rectangular area within a pattern
 Algorithm from http://www.drdobbs.com/database/the-maximal-rectangle-problem/184410529


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for rectangle finding
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        min, max of largest subrectangle
    </ol>




</dd>
    <dt>
    <a name = "maxrectangle_pattern"></a>
    <strong>maxrectangle_pattern (ip)</strong>
    </dt>
    <dd>
    Returns the pattern associated with the maximum rectangle of another pattern
 The returned pattern is in the same coordinate system as the parent.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for rectangle finding
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        rectangle pattern followed by it's min, max
    </ol>




</dd>
    <dt>
    <a name = "bsp"></a>
    <strong>bsp (rules, ip, sps)</strong>
    </dt>
    <dd>
    Performs a binary space partition upon a given pattern, returning the
 partitioned subpatterns.  This works by finding all the contiguous rectangular
 volumes in the input pattern and running a binary space partition on all of them.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">rules</span>
         the set of rules for the BSP - threshold room asymmetry (deviat) and threshold volume (volume)
        </li>
        <li><span class="parameter">ip</span>
         the pattern for which the BSP will be run over
        </li>
        <li><span class="parameter">sps</span>
         a table of subpatterns into which the BSP subpatterns will be inserted
        </li>
    </ul>





</dd>
    <dt>
    <a name = "packtile"></a>
    <strong>packtile (a, b)</strong>
    </dt>
    <dd>
    Finds a position where pattern a can fit into pattern b and returns the shift required
 This operation does not allow for rotations


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         the tile to be packed
        </li>
        <li><span class="parameter">b</span>
         the domain which we are searching for packing solutions
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a point in b where a can be placed
    </ol>




</dd>
    <dt>
    <a name = "packtile_centre"></a>
    <strong>packtile_centre (a, b)</strong>
    </dt>
    <dd>
    Center-weighted version of pattern.packtile, tries to fit
 pattern a into as close as possible to pattern b's centre


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         the tile to be packed
        </li>
        <li><span class="parameter">b</span>
         the domain which we are searching for packing solutions
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a point in b where a can be placed
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2018-01-16 01:24:22 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
