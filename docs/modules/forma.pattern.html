<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>forma Reference Manual</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>forma</h1>

<ul>
  <li><a href="../contents.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Basic_methods">Basic methods </a></li>
<li><a href="#Metamethods">Metamethods </a></li>
<li><a href="#Pattern_cell_selectors">Pattern cell selectors </a></li>
<li><a href="#Pattern_manipulators">Pattern manipulators </a></li>
<li><a href="#Packing_methods">Packing methods </a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/forma.cell.html">forma.cell</a></li>
  <li><strong>forma.pattern</strong></li>
  <li><a href="../modules/forma.primitives.html">forma.primitives</a></li>
  <li><a href="../modules/forma.subpattern.html">forma.subpattern</a></li>
  <li><a href="../modules/forma.automata.html">forma.automata</a></li>
  <li><a href="../modules/forma.neighbourhood.html">forma.neighbourhood</a></li>
</ul>
<h2>Readme</h2>
<ul class="nowrap">
  <li><a href="../readme/README.md.html">README</a></li>
</ul>
<h2>Examples</h2>
<ul class="nowrap">
  <li><a href="../examples/carpet.lua.html">carpet.lua</a></li>
  <li><a href="../examples/caves.lua.html">caves.lua</a></li>
  <li><a href="../examples/corridors.lua.html">corridors.lua</a></li>
  <li><a href="../examples/game_of_life.lua.html">game_of_life.lua</a></li>
  <li><a href="../examples/game_of_life_async.lua.html">game_of_life_async.lua</a></li>
  <li><a href="../examples/primitives.lua.html">primitives.lua</a></li>
  <li><a href="../examples/shapes.lua.html">shapes.lua</a></li>
  <li><a href="../examples/town.lua.html">town.lua</a></li>
  <li><a href="../examples/voronoi.lua.html">voronoi.lua</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>forma.pattern</code></h1>
<p>A class containing a set or <em>pattern</em> of cells.</p>
<p>


<p> The <strong>pattern</strong> class is the central class of this module, representing a
 set of <a href="../modules/forma.cell.html">cell</a>s. This set can be initialised as empty, or according to
 geometric <a href="../modules/forma.primitives.html">primitives</a>. Once initialised, a pattern can only be modified by
 the <a href="../modules/forma.pattern.html#insert">insert</a> method, used to add active cells. All other pattern manipulations
 return a new, modified pattern rather than modifying patterns in-place.</p>

<p> Several pattern manipulators are provided here. For example as a <a href="../modules/forma.pattern.html#shift">shift</a> of
 an entire pattern, manipulators that <a href="../modules/forma.pattern.html#enlarge">enlarge</a> a pattern by a scale factor
 or performing reflections in the x or y axes. Particuarly useful are
 manipulators which generate new patterns as the <a href="../modules/forma.pattern.html#edge">edge</a> (outer hull) or
 <a href="../modules/forma.pattern.html#surface">surface</a> (inner-hull) of other patterns. These manipulators can be used
 with different definitions of a cell's <a href="../modules/forma.neighbourhood.html">neighbourhood</a>.</p>

<p> Pattern coordinates should be reasonably reliable in [-65536, 65536] and
 probably beyond. But don't push your luck.</p>

<p> Through an abuse of metatables, all functions can be used either 'procedurally' as</p>

<pre>
pattern.method(input_pattern, ... )
</pre>

<p> or as a class method</p>

<pre>
input_pattern:method(...)
</pre>

</p>
    <h3>Usage:</h3>
    <ul>
        <pre class="example">-- &apos;Procedural&apos; style pattern creation
local p1 = pattern.new()
pattern.insert(p1, 1,1)

-- &apos;Method&apos; style with chaining used for :insert
local p2 = pattern.new():insert(1,1) -- Idential as to p1

-- Fetch a random cell and the centre-of-mass cell from a pattern
local random_cell = p1:rcell()
local com_cell = p1:com()

-- Compute the outer (outside the existing pattern) hull
-- Using 8-direction (Moore) neighbourhood
local outer_hull = p1:edge(neighbourhood.moore())
-- or equivalently
outer_hull = pattern.edge(p1, neighbourhood.moore())
</pre>
    </ul>


<h2><a href="#Basic_methods">Basic methods </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#new">new (prototype)</a></td>
	<td class="summary">forma.pattern constructor.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#clone">clone (ip)</a></td>
	<td class="summary">Copy an existing forma.pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#insert">insert (ip, x, y)</a></td>
	<td class="summary">Insert a new cell into a pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#has_cell">has_cell (ip, x, y)</a></td>
	<td class="summary">Check if a cell is active in a pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#cell_list">cell_list (ip)</a></td>
	<td class="summary">Return a list of cells active in the pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#size">size (ip)</a></td>
	<td class="summary">Return the number of cells active in a pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#size_sort">size_sort (pa, pb)</a></td>
	<td class="summary">Size comparator for two patterns.</td>
	</tr>
</table>
<h2><a href="#Metamethods">Metamethods </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#__tostring">__tostring (ip)</a></td>
	<td class="summary">Render pattern as a string.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#__add">__add (a, b)</a></td>
	<td class="summary">Add two patterns to each other.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#__sub">__sub (a, b)</a></td>
	<td class="summary">Subtract one pattern from another.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#__eq">__eq (a, b)</a></td>
	<td class="summary">Pattern equality test.</td>
	</tr>
</table>
<h2><a href="#Pattern_cell_selectors">Pattern cell selectors </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#rcell">rcell (ip, rng)</a></td>
	<td class="summary">Pattern random cell method.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#com">com (ip)</a></td>
	<td class="summary">Pattern centre of mass cell method.</td>
	</tr>
</table>
<h2><a href="#Pattern_manipulators">Pattern manipulators </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#shift">shift (ip, x, y)</a></td>
	<td class="summary">Generate a copy of a pattern shifted by a vector(x,y)</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#normalise">normalise (ip)</a></td>
	<td class="summary">Copy a pattern, shifting its origin to (0,0).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#enlarge">enlarge (ip, f)</a></td>
	<td class="summary">Generate an enlarged version of a pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#vreflect">vreflect (ip)</a></td>
	<td class="summary">Generate a copy of a pattern, mirroring it vertically.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#hreflect">hreflect (ip)</a></td>
	<td class="summary">Generate a copy of a pattern, mirroring it horizontally.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#edge">edge (ip, nbh)</a></td>
	<td class="summary">Generate a pattern consisting of edge cells to a provided pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#surface">surface (ip, nbh)</a></td>
	<td class="summary">Generate a pattern consisting of cells on the surface of a provided pattern.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#intersection">intersection (...)</a></td>
	<td class="summary">Generate a pattern consisting of the intersection of existing patterns</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#sum">sum (...)</a></td>
	<td class="summary">Generate a pattern consisting of the sum of existing patterns</td>
	</tr>
</table>
<h2><a href="#Packing_methods">Packing methods </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#packtile">packtile (a, b)</a></td>
	<td class="summary">Returns a cell where pattern <code>a</code> overlaps with pattern <code>b</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#packtile_centre">packtile_centre (a, b)</a></td>
	<td class="summary">Center-weighted version of pattern.packtile.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header has-description"><a name="Basic_methods"></a>Basic methods </h2>

          <div class="section-description">
           Methods for the creation, copying and adding of cells to a pattern.
          </div>
    <dl class="function">
    <dt>
    <a name = "new"></a>
    <strong>new (prototype)</strong>
    </dt>
    <dd>
    forma.pattern constructor.
 Points are stored in the pattern in a standard integer keyed table, and
 also as elements in a spatial hash map.
 Returns a new forma.pattern. If no prototype is used, then an empty pattern
 is returned. If set with the prototype table {{1,0},{0,1}} will initialise
 the pattern:
  10
  01


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">prototype</span>
         (optional) an N*N 2D table of ones and zeros.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        new pattern
    </ol>




</dd>
    <dt>
    <a name = "clone"></a>
    <strong>clone (ip)</strong>
    </dt>
    <dd>
    Copy an existing forma.pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         input pattern for cloning
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        new forma.pattern copy of ip
    </ol>




</dd>
    <dt>
    <a name = "insert"></a>
    <strong>insert (ip, x, y)</strong>
    </dt>
    <dd>
    Insert a new cell into a pattern.
 Re-returns the provided cell to enable cascading.
 e.g <code>pattern.new():insert(x,y)</code> returns a pattern with
 a single cell at (x,y).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for cell insertion
        </li>
        <li><span class="parameter">x</span>
         first coordinate of new cell
        </li>
        <li><span class="parameter">y</span>
         second coordinate of new cell
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        ip for method cascading
    </ol>




</dd>
    <dt>
    <a name = "has_cell"></a>
    <strong>has_cell (ip, x, y)</strong>
    </dt>
    <dd>
    Check if a cell is active in a pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for cell check
        </li>
        <li><span class="parameter">x</span>
         first coordinate of cell to be returned
        </li>
        <li><span class="parameter">y</span>
         second coordinate of cell to be returned
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        True if pattern <code>ip</code> includes the cell at (x,y), False otherwise
    </ol>




</dd>
    <dt>
    <a name = "cell_list"></a>
    <strong>cell_list (ip)</strong>
    </dt>
    <dd>
    Return a list of cells active in the pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         source pattern for active cell list.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "size"></a>
    <strong>size (ip)</strong>
    </dt>
    <dd>
    Return the number of cells active in a pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for size check
        </li>
    </ul>





</dd>
    <dt>
    <a name = "size_sort"></a>
    <strong>size_sort (pa, pb)</strong>
    </dt>
    <dd>
    Size comparator for two patterns.
 Useful for table.sort to rank patterns by size (number of cells)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">pa</span>
         the first pattern for comparison
        </li>
        <li><span class="parameter">pb</span>
         the second pattern for comparison
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        pa:size() > pb:size()
    </ol>




</dd>
</dl>
    <h2 class="section-header "><a name="Metamethods"></a>Metamethods </h2>

    <dl class="function">
    <dt>
    <a name = "__tostring"></a>
    <strong>__tostring (ip)</strong>
    </dt>
    <dd>
    Render pattern as a string.
 Prints the stored pattern to string, rendered using the character stored in
 pattern.onchar for activated cells and pattern.offchar for unactivated cells.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         the forma.pattern to be rendered as a string
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        pattern as string
    </ol>




</dd>
    <dt>
    <a name = "__add"></a>
    <strong>__add (a, b)</strong>
    </dt>
    <dd>
    Add two patterns to each other.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         first pattern to be added
        </li>
        <li><span class="parameter">b</span>
         second pattern to be added
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        new forma.pattern consisting of the superset of patterns a and b
    </ol>




</dd>
    <dt>
    <a name = "__sub"></a>
    <strong>__sub (a, b)</strong>
    </dt>
    <dd>
    Subtract one pattern from another.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         base pattern
        </li>
        <li><span class="parameter">b</span>
         pattern to be subtracted from a
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        new forma.pattern consisting of the subset of cells in a which are not in b
    </ol>




</dd>
    <dt>
    <a name = "__eq"></a>
    <strong>__eq (a, b)</strong>
    </dt>
    <dd>
    Pattern equality test.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         first pattern for equality check
        </li>
        <li><span class="parameter">b</span>
         second pattern for equality check
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        true if patterns are identical, false if not
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Pattern_cell_selectors"></a>Pattern cell selectors </h2>

          <div class="section-description">
           These methods select certain cells from a pattern.
          </div>
    <dl class="function">
    <dt>
    <a name = "rcell"></a>
    <strong>rcell (ip, rng)</strong>
    </dt>
    <dd>
    Pattern random cell method.
 Returns a cell at random from the pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for random cell retrieval
        </li>
        <li><span class="parameter">rng</span>
         (optional )A random number generating table, following the signature of math.random.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a random cell in the pattern
    </ol>




</dd>
    <dt>
    <a name = "com"></a>
    <strong>com (ip)</strong>
    </dt>
    <dd>
    Pattern centre of mass cell method.
 Returns the cell closes to the mass-centre of the pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for centre of mass retrieval
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the centre of mass cell in the pattern
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Pattern_manipulators"></a>Pattern manipulators </h2>

          <div class="section-description">
           These methods generate different 'child' patterns from an input pattern.
          </div>
    <dl class="function">
    <dt>
    <a name = "shift"></a>
    <strong>shift (ip, x, y)</strong>
    </dt>
    <dd>
    Generate a copy of a pattern shifted by a vector(x,y)


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern to be shifted
        </li>
        <li><span class="parameter">x</span>
         first coordinate of shift
        </li>
        <li><span class="parameter">y</span>
         second coordinate of shift
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a new forma.pattern consisting of ip shifted by (x,y)
    </ol>




</dd>
    <dt>
    <a name = "normalise"></a>
    <strong>normalise (ip)</strong>
    </dt>
    <dd>
    Copy a pattern, shifting its origin to (0,0).


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern to be normalised
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a new normalised forma.pattern
    </ol>




</dd>
    <dt>
    <a name = "enlarge"></a>
    <strong>enlarge (ip, f)</strong>
    </dt>
    <dd>
    Generate an enlarged version of a pattern.
 This returns a new pattern in which each cell in an input pattern is
 converted to a f*f cell block. The returned pattern is in such a way an
 'enlarged' version of the input pattern, by a scale factor of 'f' in both x
 and y.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern to be enlarged
        </li>
        <li><span class="parameter">f</span>
         factor of enlargement
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        enlarged pattern
    </ol>




</dd>
    <dt>
    <a name = "vreflect"></a>
    <strong>vreflect (ip)</strong>
    </dt>
    <dd>
    Generate a copy of a pattern, mirroring it vertically.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for reflection
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        copy of <code>ip</code> which has been is reflected vertically
    </ol>




</dd>
    <dt>
    <a name = "hreflect"></a>
    <strong>hreflect (ip)</strong>
    </dt>
    <dd>
    Generate a copy of a pattern, mirroring it horizontally.
 Reflect a pattern horizontally


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for reflection
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        copy of <code>ip</code> which has been reflected horizontally
    </ol>




</dd>
    <dt>
    <a name = "edge"></a>
    <strong>edge (ip, nbh)</strong>
    </dt>
    <dd>
    Generate a pattern consisting of edge cells to a provided pattern.
 Note that this will <em>not</em> necessarily generate a hull, it just returns the
 inactive neighbours of the provided pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for which the edges should be calculated
        </li>
        <li><span class="parameter">nbh</span>
         defines which neighbourhood to scan in to determine edges (default 8/moore)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the forma.pattern represeting the edge of ip
    </ol>




</dd>
    <dt>
    <a name = "surface"></a>
    <strong>surface (ip, nbh)</strong>
    </dt>
    <dd>
    Generate a pattern consisting of cells on the surface of a provided pattern.
 This is simmilar to pattern.edge, but will return cells that are /internal/
 to the provided pattern.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ip</span>
         pattern for which the surface should be calculated
        </li>
        <li><span class="parameter">nbh</span>
         defines which neighbourhood to scan in to determine edges (default 8/moore)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the forma.pattern represeting the surface of ip
    </ol>




</dd>
    <dt>
    <a name = "intersection"></a>
    <strong>intersection (...)</strong>
    </dt>
    <dd>
    Generate a pattern consisting of the intersection of existing patterns


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         patterns for intersection calculation
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the forma.pattern representing the intersection of the arguments
    </ol>




</dd>
    <dt>
    <a name = "sum"></a>
    <strong>sum (...)</strong>
    </dt>
    <dd>
    Generate a pattern consisting of the sum of existing patterns


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         patterns for summation
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the forma.pattern represeting the sum of the arguments
    </ol>




</dd>
</dl>
    <h2 class="section-header has-description"><a name="Packing_methods"></a>Packing methods </h2>

          <div class="section-description">
           These methods are used to find locations where one pattern overlaps with
 another. They can therefore be used to 'pack' a set of pattern into another.
 Note that these methods are not intended to be anything like optimal packing
 algorithms. methods
          </div>
    <dl class="function">
    <dt>
    <a name = "packtile"></a>
    <strong>packtile (a, b)</strong>
    </dt>
    <dd>
    Returns a cell where pattern <code>a</code> overlaps with pattern <code>b</code>.
 The returned point has no particular properties w.r.t ordering of possible
 solutions. Solutions are returned 'first-come-first-served'.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
        <code> the pattern to be packed in </code>b`.
        </li>
        <li><span class="parameter">b</span>
        ` the domain which we are searching for packing solutions.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a cell in <code>b</code> where <code>a</code> can be placed, <code>nil</code> if impossible.
    </ol>




</dd>
    <dt>
    <a name = "packtile_centre"></a>
    <strong>packtile_centre (a, b)</strong>
    </dt>
    <dd>
    Center-weighted version of pattern.packtile.
 Tries to fit pattern <code>a</code> as close as possible to pattern <code>b</code>'s centre of mass.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         the pattern to be packed into pattern <code>b</code>.
        </li>
        <li><span class="parameter">b</span>
         the domain which we are searching for packing solutions
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a cell in <code>b</code> where <code>a</code> can be placed, nil if no solution found.
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2018-06-13 02:19:52 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
